/**
 * VulnerabilityScanner Tests
 * 
 * Tests for vulnerability scanning functionality with various security patterns
 * Following SOLID SRP and functional programming principles
 */

import {
  scanVulnerabilities,
  detectWeakEncryption,
  detectInsecureProtocols,
  detectWeakCredentials,
  detectSQLInjection,
  detectXSS,
  getVulnerabilitySeverity,
} from '../../../src/application/validators/VulnerabilityScanner';
import { VulnerabilityRule, VulnerabilityDetectionResult, SecurityContext } from '../../../src/shared/types/security';

describe('VulnerabilityScanner', () => {
  describe('scanVulnerabilities', () => {
    it('should return empty array for empty content', () => {
      const rules: VulnerabilityRule[] = [
        {
          id: 'test-rule',
          name: 'Test Rule',
          description: 'Test vulnerability rule',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'encryption',
          pattern: /test/gi,
          remediation: 'Test remediation'
        }
      ];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: '',
        options: {}
      };

      const result = scanVulnerabilities('', rules, context);

      expect(result).toEqual([]);
    });

    it('should return empty array for whitespace-only content', () => {
      const rules: VulnerabilityRule[] = [
        {
          id: 'test-rule',
          name: 'Test Rule',
          description: 'Test vulnerability rule',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'encryption',
          pattern: /test/gi,
          remediation: 'Test remediation'
        }
      ];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: '   \n\t  ',
        options: {}
      };

      const result = scanVulnerabilities('   \n\t  ', rules, context);

      expect(result).toEqual([]);
    });

    it('should return empty array for no rules', () => {
      const rules: VulnerabilityRule[] = [];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: 'test content',
        options: {}
      };

      const result = scanVulnerabilities('test content', rules, context);

      expect(result).toEqual([]);
    });

    it('should return empty array for null rules', () => {
      const rules: VulnerabilityRule[] = null as any;
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: 'test content',
        options: {}
      };

      const result = scanVulnerabilities('test content', rules, context);

      expect(result).toEqual([]);
    });

    it('should scan with enabled rules only', () => {
      const rules: VulnerabilityRule[] = [
        {
          id: 'enabled-rule',
          name: 'Enabled Rule',
          description: 'Enabled vulnerability rule',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'encryption',
          pattern: /MD5/gi,
          remediation: 'Use SHA-256'
        },
        {
          id: 'disabled-rule',
          name: 'Disabled Rule',
          description: 'Disabled vulnerability rule',
          type: 'vulnerability',
          severity: 'high',
          enabled: false,
          category: 'encryption',
          pattern: /SHA1/gi,
          remediation: 'Use SHA-256'
        }
      ];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: 'MD5 hash function',
        options: {}
      };

      const result = scanVulnerabilities('MD5 hash function', rules, context);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('encryption');
      expect(result[0].description).toBe('Enabled vulnerability rule');
    });

    it('should handle rules with invalid patterns', () => {
      const rules: VulnerabilityRule[] = [
        {
          id: 'invalid-rule',
          name: 'Invalid Rule',
          description: 'Invalid vulnerability rule',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'encryption',
          pattern: null as any,
          remediation: 'Test remediation'
        }
      ];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: 'test content',
        options: {}
      };

      const result = scanVulnerabilities('test content', rules, context);

      expect(result).toEqual([]);
    });

    it('should detect multiple vulnerabilities', () => {
      const rules: VulnerabilityRule[] = [
        {
          id: 'rule1',
          name: 'Rule 1',
          description: 'Test rule 1',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'encryption',
          pattern: /MD5/gi,
          remediation: 'Use SHA-256'
        },
        {
          id: 'rule2',
          name: 'Rule 2',
          description: 'Test rule 2',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'protocol',
          pattern: /http:/gi,
          remediation: 'Use HTTPS'
        }
      ];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: 'MD5 hash and http://example.com',
        options: {}
      };

      const result = scanVulnerabilities('MD5 hash and http://example.com', rules, context);

      expect(result).toHaveLength(2);
      expect(result[0].type).toBe('encryption');
      expect(result[1].type).toBe('protocol');
    });

    it('should calculate correct line and column numbers', () => {
      const rules: VulnerabilityRule[] = [
        {
          id: 'test-rule',
          name: 'Test Rule',
          description: 'Test vulnerability rule',
          type: 'vulnerability',
          severity: 'high',
          enabled: true,
          category: 'encryption',
          pattern: /MD5/gi,
          remediation: 'Use SHA-256'
        }
      ];
      const context: SecurityContext = { 
        filePath: 'test.yaml',
        content: 'line1\nline2 MD5 hash\nline3',
        options: {}
      };

      const result = scanVulnerabilities('line1\nline2 MD5 hash\nline3', rules, context);

      expect(result).toHaveLength(1);
      expect(result[0].lineNumber).toBe(2);
      expect(result[0].columnNumber).toBe(7); // MD5 starts at column 7 in line 2
    });
  });

  describe('detectWeakEncryption', () => {
    it('should return empty array for empty content', () => {
      const result = detectWeakEncryption('');

      expect(result).toEqual([]);
    });

    it('should return empty array for whitespace-only content', () => {
      const result = detectWeakEncryption('   \n\t  ');

      expect(result).toEqual([]);
    });

    it('should detect MD5 hash function', () => {
      const content = `
        const hash = MD5(password);
        console.log(hash);
      `;

      const result = detectWeakEncryption(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('encryption');
      expect(result[0].description).toContain('MD5 hash function detected');
      expect(result[0].remediation).toContain('SHA-256');
      expect(result[0].cve).toBe('CVE-2004-2761');
    });

    it('should detect SHA-1 hash function', () => {
      const content = `
        const hash = SHA1(data);
      `;

      const result = detectWeakEncryption(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('encryption');
      expect(result[0].description).toContain('SHA-1 hash function detected');
      expect(result[0].remediation).toContain('SHA-256');
      expect(result[0].cve).toBe('CVE-2005-4900');
    });

    it('should detect DES encryption', () => {
      const content = `
        const encrypted = DES(plaintext, key);
      `;

      const result = detectWeakEncryption(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('encryption');
      expect(result[0].description).toContain('DES encryption detected');
      expect(result[0].remediation).toContain('AES-256');
      expect(result[0].cve).toBe('CVE-1999-0017');
    });

    it('should detect RC4 encryption', () => {
      const content = `
        const encrypted = RC4(data, key);
      `;

      const result = detectWeakEncryption(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('encryption');
      expect(result[0].description).toContain('RC4 encryption detected');
      expect(result[0].remediation).toContain('AES-256');
      expect(result[0].cve).toBe('CVE-2015-2808');
    });

    it('should detect multiple weak encryption patterns', () => {
      const content = `
        const md5Hash = MD5(data);
        const sha1Hash = SHA1(data);
        const desEncrypted = DES(data, key);
      `;

      const result = detectWeakEncryption(content);

      expect(result).toHaveLength(3);
      expect(result[0].description).toContain('MD5');
      expect(result[1].description).toContain('SHA-1');
      expect(result[2].description).toContain('DES');
    });

    it('should handle case-insensitive matching', () => {
      const content = `
        const hash = md5(password);
        const encrypted = des(data, key);
      `;

      const result = detectWeakEncryption(content);

      expect(result).toHaveLength(2);
      expect(result[0].description).toContain('MD5');
      expect(result[1].description).toContain('DES');
    });
  });

  describe('detectInsecureProtocols', () => {
    it('should return empty array for empty content', () => {
      const result = detectInsecureProtocols('');

      expect(result).toEqual([]);
    });

    it('should detect HTTP protocol', () => {
      const content = `
        const url = "http://example.com/api";
      `;

      const result = detectInsecureProtocols(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('protocol');
      expect(result[0].description).toContain('HTTP protocol detected');
      expect(result[0].remediation).toContain('HTTPS');
      expect(result[0].cve).toBe('CVE-2014-3566');
    });

    it('should detect FTP protocol', () => {
      const content = `
        const ftpUrl = "ftp://files.example.com";
      `;

      const result = detectInsecureProtocols(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('protocol');
      expect(result[0].description).toContain('FTP protocol detected');
      expect(result[0].remediation).toContain('SFTP');
      expect(result[0].cve).toBe('CVE-1999-0017');
    });

    it('should detect Telnet protocol', () => {
      const content = `
        const telnetUrl = "telnet://server.example.com";
      `;

      const result = detectInsecureProtocols(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('protocol');
      expect(result[0].description).toContain('Telnet protocol detected');
      expect(result[0].remediation).toContain('SSH');
      expect(result[0].cve).toBe('CVE-1999-0017');
    });

    it('should detect multiple insecure protocols', () => {
      const content = `
        const httpUrl = "http://example.com";
        const ftpUrl = "ftp://files.com";
        const telnetUrl = "telnet://server.com";
      `;

      const result = detectInsecureProtocols(content);

      expect(result).toHaveLength(3);
      expect(result[0].description).toContain('HTTP');
      expect(result[1].description).toContain('FTP');
      expect(result[2].description).toContain('Telnet');
    });

    it('should handle case-insensitive matching', () => {
      const content = `
        const url1 = "HTTP://example.com";
        const url2 = "FTP://files.com";
      `;

      const result = detectInsecureProtocols(content);

      expect(result).toHaveLength(2);
      expect(result[0].description).toContain('HTTP');
      expect(result[1].description).toContain('FTP');
    });
  });

  describe('detectWeakCredentials', () => {
    it('should return empty array for empty content', () => {
      const result = detectWeakCredentials('');

      expect(result).toEqual([]);
    });

    it('should detect default admin password', () => {
      const content = `
        password = "admin";
        const creds = { password: 'admin' };
      `;

      const result = detectWeakCredentials(content);

      expect(result.length).toBeGreaterThanOrEqual(2);
      expect(result[0].type).toBe('credential');
      expect(result[0].description).toContain('Default admin password detected');
      expect(result[0].remediation).toContain('strong, unique passwords');
      expect(result[0].cve).toBe('CVE-2019-11043');
    });

    it('should detect weak password', () => {
      const content = `
        password = "password";
      `;

      const result = detectWeakCredentials(content);

      expect(result.length).toBeGreaterThanOrEqual(1);
      expect(result[0].type).toBe('credential');
      expect(result[0].description).toContain('Weak password detected');
      expect(result[0].cve).toBe('CVE-2019-11043');
    });

    it('should detect numeric password', () => {
      const content = `
        password = "123456";
      `;

      const result = detectWeakCredentials(content);

      expect(result.length).toBeGreaterThanOrEqual(1);
      expect(result[0].type).toBe('credential');
      expect(result[0].description).toContain('Weak numeric password detected');
      expect(result[0].cve).toBe('CVE-2019-11043');
    });

    it('should detect short passwords', () => {
      const content = `
        password = "abc123";
        password = "short";
      `;

      const result = detectWeakCredentials(content);

      expect(result).toHaveLength(2);
      expect(result[0].description).toContain('Short password detected');
      expect(result[1].description).toContain('Short password detected');
    });

    it('should handle different assignment formats', () => {
      const content = `
        password: "admin"
        password = "password"
        password="123456"
      `;

      const result = detectWeakCredentials(content);

      expect(result.length).toBeGreaterThanOrEqual(3);
      expect(result[0].description).toContain('Default admin password');
      expect(result[1].description).toContain('Weak password');
      expect(result[2].description).toContain('Weak numeric password');
    });

    it('should handle case-insensitive matching', () => {
      const content = `
        PASSWORD = "ADMIN";
        Password = "password";
      `;

      const result = detectWeakCredentials(content);

      expect(result.length).toBeGreaterThanOrEqual(2);
      expect(result[0].description).toContain('Default admin password');
      expect(result[1].description).toContain('Weak password');
    });
  });

  describe('detectSQLInjection', () => {
    it('should return empty array for empty content', () => {
      const result = detectSQLInjection('');

      expect(result).toEqual([]);
    });

    it('should detect SQL injection in SELECT statement', () => {
      const content = `
        const query = "SELECT * FROM users WHERE id = \${userId}";
      `;

      const result = detectSQLInjection(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('injection');
      expect(result[0].description).toContain('SQL injection vulnerability');
      expect(result[0].description).toContain('WHERE clause');
      expect(result[0].remediation).toContain('parameterized queries');
      expect(result[0].cve).toBe('CVE-2019-5418');
    });

    it('should detect SQL injection in INSERT statement', () => {
      const content = `
        const query = "INSERT INTO users VALUES (\${name}, \${email})";
      `;

      const result = detectSQLInjection(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('injection');
      expect(result[0].description).toContain('SQL injection vulnerability');
      expect(result[0].description).toContain('INSERT');
      expect(result[0].remediation).toContain('parameterized queries');
    });

    it('should detect SQL injection in UPDATE statement', () => {
      const content = `
        const query = "UPDATE users SET name = \${name} WHERE id = \${id}";
      `;

      const result = detectSQLInjection(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('injection');
      expect(result[0].description).toContain('SQL injection vulnerability');
      expect(result[0].description).toContain('UPDATE');
      expect(result[0].remediation).toContain('parameterized queries');
    });

    it('should detect multiple SQL injection patterns', () => {
      const content = `
        const selectQuery = "SELECT * FROM users WHERE id = \${userId}";
        const insertQuery = "INSERT INTO logs VALUES (\${message})";
        const updateQuery = "UPDATE users SET status = \${status} WHERE id = \${id}";
      `;

      const result = detectSQLInjection(content);

      expect(result).toHaveLength(3);
      expect(result[0].description).toContain('WHERE clause');
      expect(result[1].description).toContain('INSERT');
      expect(result[2].description).toContain('UPDATE');
    });

    it('should handle case-insensitive matching', () => {
      const content = `
        const query = "select * from users where id = \${userId}";
      `;

      const result = detectSQLInjection(content);

      expect(result).toHaveLength(1);
      expect(result[0].description).toContain('SQL injection vulnerability');
    });
  });

  describe('detectXSS', () => {
    it('should return empty array for empty content', () => {
      const result = detectXSS('');

      expect(result).toEqual([]);
    });

    it('should detect XSS in innerHTML', () => {
      const content = `
        element.innerHTML = \`<div>\${userInput}</div>\`;
      `;

      const result = detectXSS(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('xss');
      expect(result[0].description).toContain('XSS vulnerability');
      expect(result[0].description).toContain('innerHTML');
      expect(result[0].remediation).toContain('textContent');
      expect(result[0].cve).toBe('CVE-2019-5418');
    });

    it('should detect XSS in document.write', () => {
      const content = `
        document.write(\`<script>\${userInput}</script>\`);
      `;

      const result = detectXSS(content);

      expect(result).toHaveLength(1);
      expect(result[0].type).toBe('xss');
      expect(result[0].description).toContain('XSS vulnerability');
      expect(result[0].description).toContain('document.write');
      expect(result[0].remediation).toContain('DOM manipulation');
      expect(result[0].cve).toBe('CVE-2019-5418');
    });

    it('should detect multiple XSS patterns', () => {
      const content = `
        element.innerHTML = \`<div>\${userInput}</div>\`;
        document.write(\`<script>\${userInput}</script>\`);
      `;

      const result = detectXSS(content);

      expect(result).toHaveLength(2);
      expect(result[0].description).toContain('innerHTML');
      expect(result[1].description).toContain('document.write');
    });

    it('should handle case-insensitive matching', () => {
      const content = `
        element.INNERHTML = \`<div>\${userInput}</div>\`;
        DOCUMENT.WRITE(\`<script>\${userInput}</script>\`);
      `;

      const result = detectXSS(content);

      expect(result).toHaveLength(2);
      expect(result[0].description).toContain('innerHTML');
      expect(result[1].description).toContain('document.write');
    });
  });

  describe('getVulnerabilitySeverity', () => {
    it('should return medium for no CVE or CVSS score', () => {
      const result = getVulnerabilitySeverity();

      expect(result).toBe('medium');
    });

    it('should return medium for no CVE or CVSS score (explicit undefined)', () => {
      const result = getVulnerabilitySeverity(undefined, undefined);

      expect(result).toBe('medium');
    });

    it('should return critical for CVSS score >= 9.0', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234', 9.5);

      expect(result).toBe('critical');
    });

    it('should return high for CVSS score >= 7.0 and < 9.0', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234', 8.5);

      expect(result).toBe('high');
    });

    it('should return medium for CVSS score >= 4.0 and < 7.0', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234', 5.5);

      expect(result).toBe('medium');
    });

    it('should return low for CVSS score < 4.0', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234', 2.5);

      expect(result).toBe('low');
    });

    it('should return high for CVE without CVSS score', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234');

      expect(result).toBe('high');
    });

    it('should return high for CVE with undefined CVSS score', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234', undefined);

      expect(result).toBe('high');
    });

    it('should prioritize CVSS score over CVE presence', () => {
      const result = getVulnerabilitySeverity('CVE-2020-1234', 1.5);

      expect(result).toBe('low');
    });

    it('should handle edge case CVSS scores', () => {
      expect(getVulnerabilitySeverity('CVE-2020-1234', 9.0)).toBe('critical');
      expect(getVulnerabilitySeverity('CVE-2020-1234', 7.0)).toBe('high');
      expect(getVulnerabilitySeverity('CVE-2020-1234', 4.0)).toBe('medium');
    });
  });
});
